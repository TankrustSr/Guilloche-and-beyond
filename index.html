<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seamless Generative Art Modulator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            height: 100vh;
        }
        #controls {
            width: 320px;
            padding: 20px;
            background-color: #ffffff;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
            z-index: 10;
        }
        #canvasContainer {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
            overflow: hidden;
        }
        canvas {
            background-color: #000; 
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.1);
        }
        .control-group {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .sub-group {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px dashed #eee;
        }
        .sub-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }
        input[type="number"] {
            width: 60px;
            padding: 2px 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 14px;
            text-align: right;
        }
        input[type="text"], select {
            padding: 2px 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 14px;
        }
        input[type="text"] {
            width: 100%;
            margin-right: 5px;
        }
        select {
            width: 100%;
            margin-right: 5px;
        }
        .radio-group label {
            display: inline-block;
            margin-right: 10px;
            font-weight: normal;
        }
        input[type="color"] {
            width: 100%;
            height: 30px;
            padding: 0;
            border: none;
            cursor: pointer;
        }
        #exportButton {
            width: 100%;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
            margin-bottom: 20px; 
        }
        #exportButton:hover {
            background-color: #45a049;
        }
        .hidden {
            display: none;
        }
        .morph-control {
            margin-top: 10px;
        }
        #dutyCycleGroup {
            margin-top: 10px;
            padding: 5px;
            background-color: #f9fff9;
            border-radius: 4px;
        }
        .unit {
            font-weight: normal;
            font-size: 0.9em;
            color: #666;
            margin-left: 2px;
        }
        .seed-btn {
            background-color: #eee;
            border: 1px solid #ccc;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
            font-weight: bold;
            font-size: 12px;
        }
        .seed-btn:hover {
            background-color: #ddd;
        }
        .seed-btn.active {
            background-color: #bbb;
            box-shadow: inset 0 0 3px rgba(0,0,0,0.2);
        }
        .anim-btn {
            background-color: #f8f8f8;
            border: 1px solid #ccc;
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
        }
        .anim-btn:hover {
            background-color: #e0e0e0;
        }
        .anim-btn.active {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        .anim-dir-btn {
            width: 30px;
            text-align: center;
        }
        .anim-dir-btn.selected {
            background-color: #2196F3;
            color: white;
            border-color: #1976D2;
        }
        
        .collapsible-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }
        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.2s ease-out;
        }
        .is-collapsed .collapsible-content {
            display: none;
        }
        .arrow {
            transition: transform 0.2s;
        }
        .is-collapsed .arrow {
            transform: rotate(-90deg);
        }
        
        .group-title {
            font-size: 1.1em;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 2px solid #eee;
            color: #333;
        }
        
        #fxGroup {
            border-color: #FF9800;
            background-color: #fff8e1;
        }
        #presetGroup {
            border-color: #607D8B;
            background-color: #eceff1;
        }
        
        /* New Modulation Options Style */
        #radiatingModOptions label {
            font-weight: normal;
            justify-content: flex-start;
            gap: 10px;
        }
    </style>
</head>
<body>

    <div id="controls">
        
        <div class="control-group" id="presetGroup">
            <label class="group-title">Preset Manager</label>
            <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                <select id="presetSelect" style="flex-grow: 1;">
                    <option value="" disabled selected>Select Preset...</option>
                </select>
                <button id="btnLoadPreset" class="anim-btn">Load</button>
                <button id="btnDeletePreset" class="anim-btn" style="color: #d32f2f; border-color: #ef9a9a;">X</button>
            </div>
            <div style="display: flex; gap: 5px;">
                <input type="text" id="presetName" placeholder="New Preset Name">
                <button id="btnSavePreset" class="anim-btn" style="width: 60px;">Save</button>
            </div>
        </div>

        <div class="control-group">
            <label>Layout Mode:</label>
            <div class="radio-group">
                <input type="radio" id="concentric" name="layoutMode" value="concentric" checked>
                <label for="concentric">Concentric</label>

                <input type="radio" id="radial" name="layoutMode" value="radial">
                <label for="radial">Radial Array</label>
                
                <input type="radio" id="radiating" name="layoutMode" value="radiating">
                <label for="radiating">Radiating Lines</label>
            </div>
        </div>
        
        <div class="control-group">
            <label for="globalRotationNum">Global Rotation (Z-Axis): <input type="number" id="globalRotationNum" min="-179" max="179" step="1" value="0"></label>
            <input type="range" id="globalRotation" min="-179" max="179" step="1" value="0">
        </div>

        <div class="control-group" id="baseRadiusGroup">
            <label for="startRadiusNum"><span id="startRadiusLabelText">Inner Radius:</span> <input type="number" id="startRadiusNum" min="0" max="375" step="1" value="20"></label>
            <input type="range" id="startRadius" min="0" max="375" step="1" value="20">

            <label for="endRadiusNum"><span id="endRadiusLabelText">Outer Radius:</span> <input type="number" id="endRadiusNum" min="1" max="500" step="1" value="350"></label>
            <input type="range" id="endRadius" min="1" max="500" step="1" value="350">
        </div>

        <div class="control-group" id="sharedCountControl">
             <label for="countNum">Item Count / Rays: <input type="number" id="countNum" min="4" max="1000" step="1" value="80"></label>
            <input type="range" id="count" min="4" max="1000" step="1" value="80"> 
        </div>
        
        <div class="control-group" id="concentricCountGroup">
            <label for="concentricCountNum">Shape Count: <input type="number" id="concentricCountNum" min="5" max="200" step="1" value="50"></label>
            <input type="range" id="concentricCount" min="5" max="200" step="1" value="50">
        </div>

        <div class="control-group">
            <label for="startLineWidthNum">Start Line Width: <input type="number" id="startLineWidthNum" min="0.1" max="50" step="0.1" value="2.0"></label>
            <input type="range" id="startLineWidth" min="0.1" max="50" step="0.1" value="2.0">
            
            <label for="endLineWidthNum">End Line Width: <input type="number" id="endLineWidthNum" min="0.1" max="50" step="0.1" value="2.0"></label>
            <input type="range" id="endLineWidth" min="0.1" max="50" step="0.1" value="2.0">
        </div>
        
        <div class="control-group" id="fxGroup">
            <label class="group-title">Visual Effects (FX)</label>
            
            <div style="margin-bottom: 10px;">
                <input type="checkbox" id="trailsEnabled">
                <label for="trailsEnabled" style="display:inline;">Enable Trails / Glow</label>
            </div>
            
            <label for="trailDecayNum" style="font-weight:normal; font-size:0.9em;">Trail Decay (Fade Speed): <input type="number" id="trailDecayNum" min="0.01" max="0.99" step="0.01" value="0.10"></label>
            <input type="range" id="trailDecay" min="0.01" max="0.99" step="0.01" value="0.10">
            
            <label for="trailZNum" style="font-weight:normal; font-size:0.9em; margin-top:5px;">Negative Z Flow Speed: <input type="number" id="trailZNum" min="0" max="50" step="1" value="0"></label>
            <input type="range" id="trailZ" min="0" max="50" step="1" value="0">
            
            <div style="margin-top: 10px;">
                <input type="checkbox" id="glowEnabled">
                <label for="glowEnabled" style="display:inline;">Additive Glow Mode</label>
            </div>
        </div>

        <div class="control-group" id="concentricRotationGroup">
            <label class="group-title">Rotation</label>
            
            <label for="concRotStartNum" style="font-weight:normal;">Start Rotation (°): <input type="number" id="concRotStartNum" min="-720" max="720" step="1" value="0"></label>
            <input type="range" id="concRotStart" min="-720" max="720" step="1" value="0">

            <label for="concRotEndNum" style="font-weight:normal; margin-top:5px;">End Rotation (°): <input type="number" id="concRotEndNum" min="-720" max="720" step="1" value="90"></label>
            <input type="range" id="concRotEnd" min="-720" max="720" step="1" value="90">
            
            <label for="angleOffsetLogNum" style="font-weight:normal; margin-top:10px;">Rotation Log Dist: <input type="number" id="angleOffsetLogNum" min="0.1" max="5" step="0.01" value="1.0"></label>
            <input type="range" id="angleOffsetLog" min="0.1" max="5" step="0.01" value="1.0">
            
            <div id="rotationModeGroup" style="margin-top:10px;">
                <label style="font-weight:normal;">Rotation Mode:</label>
                <div class="radio-group">
                    <input type="radio" id="rotateCenters" name="angleOffsetMode" value="rotateCenters">
                    <label for="rotateCenters">Spiral Position</label>
                    <input type="radio" id="rotateShapes" name="angleOffsetMode" value="rotateShapes" checked>
                    <label for="rotateShapes">Twist Shapes</label>
                </div>
            </div>
        </div>

        <div class="control-group" id="modulationGroup">
            <label class="group-title">Modulation Settings</label>

            <div class="sub-group" id="modTargetGroup">
                <label>Modulation Target:</label>
                <div class="radio-group">
                    <input type="radio" id="targetSize" name="modTarget" value="size">
                    <label for="targetSize">Shape Size</label>
                    <input type="radio" id="targetOutline" name="modTarget" value="outline" checked>
                    <label for="targetOutline">Shape Outline</label>
                </div>
            </div>

            <div class="sub-group hidden" id="radiatingModOptions">
                <label>Modulation Targets:</label>
                <div style="margin-left: 5px;">
                    <input type="checkbox" id="modLineShape" checked>
                    <label for="modLineShape" style="display:inline;">Bend Line (Shape)</label>
                </div>
                <div style="margin-left: 5px;">
                    <input type="checkbox" id="modStartRadius">
                    <label for="modStartRadius" style="display:inline;">Modulate Start Radius</label>
                </div>
                <div style="margin-left: 5px;">
                    <input type="checkbox" id="modEndRadius">
                    <label for="modEndRadius" style="display:inline;">Modulate End Radius</label>
                </div>
            </div>

            <div class="sub-group">
                <label>Waveform:</label>
                <div class="radio-group">
                    <input type="radio" id="sine" name="waveform" value="sine" checked>
                    <label for="sine">Sine</label>
                    <input type="radio" id="square" name="waveform" value="square">
                    <label for="square">Sq.</label>
                    <input type="radio" id="sawtooth" name="waveform" value="sawtooth">
                    <label for="sawtooth">Saw.</label>
                    <input type="radio" id="triangle" name="waveform" value="triangle">
                    <label for="triangle">Tri.</label>
                    <input type="radio" id="noise" name="waveform" value="noise">
                    <label for="noise">Noise</label>
                </div>
                <div id="dutyCycleGroup" class="hidden">
                    <label for="dutyCycleNum" style="font-weight:normal;">Square Duty Cycle (%): <input type="number" id="dutyCycleNum" min="0.01" max="0.99" step="0.01" value="0.50"></label>
                    <input type="range" id="dutyCycle" min="0.01" max="0.99" step="0.01" value="0.50">
                </div>
            </div>

            <div class="sub-group">
                <label for="freqNum">Modulation Cycles: <input type="number" id="freqNum" min="0" max="200" step="1" value="50"></label>
                <input type="range" id="freq" min="0" max="200" step="1" value="50">

                <div style="margin-top:15px; display:flex; justify-content:space-between; align-items:center;">
                    <label style="margin:0;">Phase Offset (<span class="unit">x $\pi$</span>):</label>
                    <div style="display:flex; gap:5px;">
                        <button id="animRev" class="anim-btn anim-dir-btn" title="Reverse">«</button>
                        <button id="animToggle" class="anim-btn" style="min-width:50px;">Play</button>
                        <button id="animFwd" class="anim-btn anim-dir-btn selected" title="Forward">»</button>
                    </div>
                </div>
                
                <div style="display: flex; align-items: center; gap: 5px; margin-top:5px;">
                    <input type="range" id="phase" min="0" max="2" step="0.001" value="0" style="flex-grow:1;">
                    <input type="number" id="phaseNum" min="0" max="2" step="0.01" value="0">
                </div>
            </div>

            <div class="sub-group">
                <label>Amplitude:</label>
                <label for="startAmpNum" style="font-weight:normal; font-size: 0.9em;">Start (Inner): <input type="number" id="startAmpNum" min="0" max="500" step="1" value="0"></label>
                <input type="range" id="startAmp" min="0" max="500" step="1" value="0">
                
                <label for="endAmpNum" style="font-weight:normal; font-size: 0.9em; margin-top:5px;">End (Outer): <input type="number" id="endAmpNum" min="0" max="500" step="1" value="40"></label>
                <input type="range" id="endAmp" min="0" max="500" step="1" value="40">

                <label for="ampLogNum" style="font-weight:normal; font-size: 0.9em; margin-top:5px;">Amp Log Dist: <input type="number" id="ampLogNum" min="0.1" max="5" step="0.01" value="1.0"></label>
                <input type="range" id="ampLog" min="0.1" max="5" step="0.01" value="1.0">
            </div>
        </div>

        <div class="control-group hidden" id="radialShapeRotGroup">
            <label>Shape Orientation (Z-Axis):</label>
            <label for="radialRotStartNum" style="font-weight:normal; margin-top:5px;">Start Rotation (°): <input type="number" id="radialRotStartNum" min="-720" max="720" step="1" value="90"></label>
            <input type="range" id="radialRotStart" min="-720" max="720" step="1" value="90">

            <label for="radialRotEndNum" style="font-weight:normal; margin-top:5px;">End Rotation (°): <input type="number" id="radialRotEndNum" min="-720" max="720" step="1" value="450"></label>
            <input type="range" id="radialRotEnd" min="-720" max="720" step="1" value="450">
        </div>

        <div class="control-group">
            <label>Color Gradient:</label>
            <label for="startColor" style="font-weight:normal; font-size: 0.9em;">Start Color (Inner/First):</label>
            <input type="color" id="startColor" value="#FF0000">
            
            <label for="endColor" style="font-weight:normal; font-size: 0.9em; margin-top:5px;">End Color (Outer/Last):</label>
            <input type="color" id="endColor" value="#0000FF">
        </div>

        <div class="control-group">
            <label>Gradient Direction:</label>
            <div class="radio-group">
                <input type="radio" id="gradAngular" name="gradientMode" value="angular" checked>
                <label for="gradAngular">Angular (Clockwise)</label>
                <input type="radio" id="gradRadial" name="gradientMode" value="radial">
                <label for="gradRadial">Radial (Lengthwise)</label>
            </div>
        </div>

        <div class="control-group" id="gradientCyclesGroup">
            <label for="gradientDivisionsNum">Gradient Cycles (360°): <input type="number" id="gradientDivisionsNum" min="1" max="36" step="1" value="1"></label>
            <input type="range" id="gradientDivisions" min="1" max="36" step="1" value="1">
        </div>
        
        <div class="control-group hidden" id="randomLengthGroup" style="border-color: #9C27B0; background-color: #fdf5ff;">
            <label>Radiating Line Lengths:</label>
            <div class="radio-group" style="display: flex; flex-direction: column; gap: 5px;">
                <div>
                    <input type="radio" id="randNone" name="randomLengthMode" value="none" checked>
                    <label for="randNone">Uniform</label>
                </div>
                <div>
                    <input type="radio" id="randStart" name="randomLengthMode" value="start">
                    <label for="randStart">Random Start</label>
                </div>
                <div>
                    <input type="radio" id="randEnd" name="randomLengthMode" value="end">
                    <label for="randEnd">Random End</label>
                </div>
                <div>
                    <input type="radio" id="randBoth" name="randomLengthMode" value="both">
                    <label for="randBoth">Random Both</label>
                </div>
            </div>
            <div style="margin-top: 15px; border-top: 1px dashed #ccc; padding-top: 10px; display: flex; justify-content: space-between; align-items: center;">
                <label style="margin: 0; font-weight: normal;">Random Seed: <span id="seedDisplay" style="font-weight: bold; margin-left:5px;">1</span></label>
                <div>
                    <button class="seed-btn" id="seedDec">&lt;</button>
                    <button class="seed-btn" id="seedInc">&gt;</button>
                </div>
            </div>
        </div>
        
        <div class="control-group hidden" id="radialAngleGroup">
            <label>Array Angle Range:</label>
            <label for="arrayStartAngleNum" style="font-weight:normal; margin-top:5px;">Start Angle (°): <input type="number" id="arrayStartAngleNum" min="0" max="360" step="1" value="0"></label>
            <input type="range" id="arrayStartAngle" min="0" max="360" step="1" value="0">

            <label for="arrayEndAngleNum" style="font-weight:normal; margin-top:5px;">End Angle (°): <input type="number" id="arrayEndAngleNum" min="0" max="360" step="1" value="360"></label>
            <input type="range" id="arrayEndAngle" min="0" max="360" step="1" value="360">
        </div>
        
        <div class="control-group" id="shapeMorphGroup">
            <label id="shapeMorphLabel">Shape Morphing:</label>
            <div class="morph-control">
                <label for="startSidesNum">Start Sides (<span id="startSidesLabel">Circle</span>): <input type="number" id="startSidesNum" min="0" max="60" step="1" value="0"></label>
                <input type="range" id="startSides" min="0" max="60" step="1" value="0">
            </div>
            <div class="morph-control">
                <label for="endSidesNum">End Sides (<span id="endSidesLabel">Circle</span>): <input type="number" id="endSidesNum" min="0" max="60" step="1" value="0"></label>
                <input type="range" id="endSides" min="0" max="60" step="1" value="0">
            </div>
        </div>

        <div class="control-group hidden" id="radialControls">
            <label>Array Path Curve:</label>
            <div class="radio-group">
                <input type="radio" id="pathRadial" name="arrayPath" value="radial" >
                <label for="pathRadial">Radial (Equal)</label>

                <input type="radio" id="pathFibonacci" name="arrayPath" value="fibonacci">
                <label for="pathFibonacci">Fibonacci Spiral</label>
            </div>

            <div id="pathLogGroup">
                <label for="pathLogNum">Path Log Dist: <input type="number" id="pathLogNum" min="0.1" max="5" step="0.01" value="1.0"></label>
                <input type="range" id="pathLog" min="0.1" max="5" step="0.01" value="1.0">
            </div>

            <div id="spiralTypeGroup" class="control-group" style="padding: 10px; border: 1px dashed #ccc;">
                <label>Spiral Type:</label>
                <div class="radio-group">
                    <input type="radio" id="typeFermat" name="spiralType" value="fermat">
                    <label for="typeFermat">Fermat Spiral</label>

                    <input type="radio" id="typePhyllotaxis" name="spiralType" value="phyllotaxis">
                    <label for="typePhyllotaxis">Phyllotaxis</label>
                </div>
            </div>
            
            <div id="spiralTurnsGroup">
                <label for="spiralTurnsNum">Spiral Turns: <input type="number" id="spiralTurnsNum" min="0.5" max="50" step="0.1" value="0.5"></label>
                <input type="range" id="spiralTurns" min="0.5" max="50" step="0.1" value="0.5">
            </div>

            <div id="numSpiralsGroup">
                <label for="numSpiralsNum">Number of Spirals: <input type="number" id="numSpiralsNum" min="1" max="40" step="1" value="1"></label>
                <input type="range" id="numSpirals" min="1" max="40" step="1" value="1">
            </div>

            <div id="debugTools">
                <label>Debugging Tools:</label>
                <input type="checkbox" id="drawPathCurve">
                <label for="drawPathCurve" style="display: inline-block;">Draw Spiral Curve</label>
            </div>

            <div id="arrayRadiusGroup">
                <label for="arrayRadiusNum"><span id="radiusLabelText">Max Array Radius:</span> <input type="number" id="arrayRadiusNum" min="0" max="350" step="1" value="267"></label>
                <input type="range" id="arrayRadius" min="0" max="350" step="1" value="267">
            </div>
            
            <div style="display: none;"> 
                <label for="startBaseRadiusNum">Start Base Radius: <input type="number" id="startBaseRadiusNum" min="1" max="300" step="1" value="50"></label>
                <input type="range" id="startBaseRadius" min="1" max="300" step="1" value="50">

                <label for="endBaseRadiusNum">End Base Radius: <input type="number" id="endBaseRadiusNum" min="1" max="300" step="1" value="50"></label>
                <input type="range" id="endBaseRadius" min="1" max="300" step="1" value="50">
            </div>
        </div>

        <div class="control-group hidden" id="concentricControls">
            <div id="distLogGroup">
                <label for="distLogNum">Concentric Log Dist: <input type="number" id="distLogNum" min="0.1" max="5" step="0.01" value="0.81"></label>
                <input type="range" id="distLog" min="0.1" max="5" step="0.01" value="0.81">
            </div>
        </div>
        
        <button id="exportButton">Export as SVG</button>

        <div class="control-group is-collapsed" id="viewControls">
            <div class="collapsible-header">
                <label style="margin-bottom:0; cursor:pointer;">3D Canvas Orientation</label>
                <span class="arrow">▼</span>
            </div>
            <div class="collapsible-content">
                <label for="tiltXNum" style="font-weight:normal; margin-top:5px;">Tilt (X-Axis): <input type="number" id="tiltXNum" min="-85" max="85" step="1" value="0"></label>
                <input type="range" id="tiltX" min="-85" max="85" step="1" value="0">

                <label for="panYNum" style="font-weight:normal; margin-top:5px;">Pan (Y-Axis): <input type="number" id="panYNum" min="-85" max="85" step="1" value="0"></label>
                <input type="range" id="panY" min="-85" max="85" step="1" value="0">
                
                <label for="perspectiveNum" style="font-weight:normal; margin-top:5px;">Perspective: <input type="number" id="perspectiveNum" min="200" max="2000" step="10" value="1000"></label>
                <input type="range" id="perspective" min="200" max="2000" step="10" value="1000">
            </div>
        </div>

    </div>

    <div id="canvasContainer">
        <canvas id="artCanvas" width="800" height="800"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('artCanvas');
        const container = document.getElementById('canvasContainer');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;
        const centerX = W / 2;
        const centerY = H / 2;
        const SPIRAL_DEBUG_SEGMENTS = 500; 
        const GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5)); 
        const MAX_CANVAS_RADIUS = Math.min(W, H) / 2; 

        const SCREEN_SEGMENTS = 1200; 
        const EXPORT_SEGMENTS = 3600;
        const MIN_POLYGON_SIDES = 3;
        const MAX_POLYGON_SIDES = 60;
        const RADIATING_LINE_SEGMENTS = 200; 

        // Toggle collapsible
        const viewHeader = document.querySelector('#viewControls .collapsible-header');
        viewHeader.addEventListener('click', () => {
            document.getElementById('viewControls').classList.toggle('is-collapsed');
        });

        function linkInputs(rangeId, numberId) {
            const range = document.getElementById(rangeId);
            const number = document.getElementById(numberId);
            if(!range || !number) return;

            range.addEventListener('input', () => {
                number.value = range.value;
                updateState();
            });

            number.addEventListener('input', () => {
                let val = parseFloat(number.value);
                const min = parseFloat(number.min);
                const max = parseFloat(number.max);
                if (!isNaN(val)) {
                    if(val < min) val = min;
                    if(val > max) val = max;
                    range.value = val;
                    updateState();
                }
            });
        }

        const controls = {
            startColor: document.getElementById('startColor'),
            endColor: document.getElementById('endColor'),
            
            // Presets
            presetSelect: document.getElementById('presetSelect'),
            presetName: document.getElementById('presetName'),
            btnLoadPreset: document.getElementById('btnLoadPreset'),
            btnDeletePreset: document.getElementById('btnDeletePreset'),
            btnSavePreset: document.getElementById('btnSavePreset'),
            
            tiltX: document.getElementById('tiltX'),
            panY: document.getElementById('panY'),
            perspective: document.getElementById('perspective'),

            freq: document.getElementById('freq'),
            phase: document.getElementById('phase'),
            startAmp: document.getElementById('startAmp'),
            endAmp: document.getElementById('endAmp'),
            startLineWidth: document.getElementById('startLineWidth'),
            endLineWidth: document.getElementById('endLineWidth'),
            ampLog: document.getElementById('ampLog'),
            distLog: document.getElementById('distLog'),
            pathLog: document.getElementById('pathLog'),
            angleOffsetLog: document.getElementById('angleOffsetLog'), 
            arrayRadius: document.getElementById('arrayRadius'),
            count: document.getElementById('count'),
            concentricCount: document.getElementById('concentricCount'),
            concRotStart: document.getElementById('concRotStart'), 
            concRotEnd: document.getElementById('concRotEnd'), 
            startRadius: document.getElementById('startRadius'), 
            endRadius: document.getElementById('endRadius'),     
            numSpirals: document.getElementById('numSpirals'), 
            spiralTurns: document.getElementById('spiralTurns'), 
            startBaseRadius: document.getElementById('startBaseRadius'),
            endBaseRadius: document.getElementById('endBaseRadius'),
            startSides: document.getElementById('startSides'),
            endSides: document.getElementById('endSides'),
            dutyCycle: document.getElementById('dutyCycle'),
            gradientDivisions: document.getElementById('gradientDivisions'), 
            globalRotation: document.getElementById('globalRotation'),

            drawPathCurve: document.getElementById('drawPathCurve'), 
            waveformRadios: document.querySelectorAll('input[name="waveform"]'),
            layoutRadios: document.querySelectorAll('input[name="layoutMode"]'),
            targetRadios: document.querySelectorAll('input[name="modTarget"]'),
            arrayPathRadios: document.querySelectorAll('input[name="arrayPath"]'), 
            spiralTypeRadios: document.querySelectorAll('input[name="spiralType"]'), 
            gradientModeRadios: document.querySelectorAll('input[name="gradientMode"]'), 
            radialControls: document.getElementById('radialControls'),
            concentricControls: document.getElementById('concentricControls'),
            arrayRadiusGroup: document.getElementById('arrayRadiusGroup'),
            numSpiralsGroup: document.getElementById('numSpiralsGroup'),
            spiralTurnsGroup: document.getElementById('spiralTurnsGroup'),
            spiralTypeGroup: document.getElementById('spiralTypeGroup'), 
            pathLogGroup: document.getElementById('pathLogGroup'),
            distLogGroup: document.getElementById('distLogGroup'), 
            debugTools: document.getElementById('debugTools'),
            exportButton: document.getElementById('exportButton'),
            startSidesLabelSpan: document.getElementById('startSidesLabel'),
            endSidesLabelSpan: document.getElementById('endSidesLabel'),
            angleOffsetModeRadios: document.querySelectorAll('input[name="angleOffsetMode"]'),
            sharedCountControl: document.getElementById('sharedCountControl'),
            modTargetGroup: document.getElementById('modTargetGroup'),
            morphControls: document.querySelectorAll('.morph-control'),
            rotationModeGroup: document.getElementById('rotationModeGroup'),
            concentricCountGroup: document.getElementById('concentricCountGroup'),
            dutyCycleGroup: document.getElementById('dutyCycleGroup'),
            gradientCyclesGroup: document.getElementById('gradientCyclesGroup'),
            randomLengthGroup: document.getElementById('randomLengthGroup'), 
            randomLengthRadios: document.querySelectorAll('input[name="randomLengthMode"]'),
            seedDisplay: document.getElementById('seedDisplay'), 
            seedInc: document.getElementById('seedInc'), 
            seedDec: document.getElementById('seedDec'), 
            shapeMorphGroup: document.getElementById('shapeMorphGroup'),
            radialAngleGroup: document.getElementById('radialAngleGroup'),
            arrayStartAngle: document.getElementById('arrayStartAngle'),
            arrayEndAngle: document.getElementById('arrayEndAngle'),
            radialShapeRotGroup: document.getElementById('radialShapeRotGroup'), 
            radialRotStart: document.getElementById('radialRotStart'), 
            radialRotEnd: document.getElementById('radialRotEnd'), 
            concentricRotationGroup: document.getElementById('concentricRotationGroup'), 
            
            // Animation Controls
            animToggle: document.getElementById('animToggle'),
            animRev: document.getElementById('animRev'),
            animFwd: document.getElementById('animFwd'),
            
            // FX Controls
            trailsEnabled: document.getElementById('trailsEnabled'),
            trailDecay: document.getElementById('trailDecay'),
            trailDecayNum: document.getElementById('trailDecayNum'),
            trailZ: document.getElementById('trailZ'),
            trailZNum: document.getElementById('trailZNum'),
            glowEnabled: document.getElementById('glowEnabled'),

            // Mod Controls
            radiatingModOptions: document.getElementById('radiatingModOptions'),
            modLineShape: document.getElementById('modLineShape'),
            modStartRadius: document.getElementById('modStartRadius'),
            modEndRadius: document.getElementById('modEndRadius'),
        };
        
        const startRadiusLabelText = document.getElementById('startRadiusLabelText');
        const endRadiusLabelText = document.getElementById('endRadiusLabelText');
        const twistLabel = document.getElementById('twistLabel');

        linkInputs('tiltX', 'tiltXNum');
        linkInputs('panY', 'panYNum');
        linkInputs('perspective', 'perspectiveNum');
        linkInputs('startLineWidth', 'startLineWidthNum');
        linkInputs('endLineWidth', 'endLineWidthNum');
        linkInputs('startRadius', 'startRadiusNum');
        linkInputs('endRadius', 'endRadiusNum');
        linkInputs('dutyCycle', 'dutyCycleNum');
        linkInputs('freq', 'freqNum');
        linkInputs('phase', 'phaseNum');
        linkInputs('ampLog', 'ampLogNum');
        linkInputs('startAmp', 'startAmpNum');
        linkInputs('endAmp', 'endAmpNum');
        linkInputs('count', 'countNum');
        linkInputs('pathLog', 'pathLogNum');
        linkInputs('spiralTurns', 'spiralTurnsNum');
        linkInputs('numSpirals', 'numSpiralsNum');
        linkInputs('arrayRadius', 'arrayRadiusNum');
        linkInputs('startBaseRadius', 'startBaseRadiusNum');
        linkInputs('endBaseRadius', 'endBaseRadiusNum');
        linkInputs('startSides', 'startSidesNum');
        linkInputs('endSides', 'endSidesNum');
        linkInputs('concentricCount', 'concentricCountNum');
        linkInputs('distLog', 'distLogNum');
        linkInputs('concRotStart', 'concRotStartNum'); 
        linkInputs('concRotEnd', 'concRotEndNum'); 
        linkInputs('angleOffsetLog', 'angleOffsetLogNum');
        linkInputs('gradientDivisions', 'gradientDivisionsNum'); 
        linkInputs('arrayStartAngle', 'arrayStartAngleNum');
        linkInputs('arrayEndAngle', 'arrayEndAngleNum'); 
        linkInputs('radialRotStart', 'radialRotStartNum'); 
        linkInputs('radialRotEnd', 'radialRotEndNum'); 
        linkInputs('globalRotation', 'globalRotationNum');
        linkInputs('trailDecay', 'trailDecayNum'); 
        linkInputs('trailZ', 'trailZNum'); 

        const waveforms = {
            sine: (t, phase) => Math.sin(t + phase),
            square: (t, phase) => {
                let val = (t + phase) % (Math.PI * 2);
                if (val < 0) val += Math.PI * 2;
                return val < (state.dutyCycle * Math.PI * 2) ? 1 : -1;
            },
            sawtooth: (t, phase) => ((t + phase / Math.PI / 2) % 1) * 2 - 1, 
            triangle: (t, phase) => 2 * Math.abs(((t + phase) / (Math.PI * 2)) % 1 - 0.5) * 2 - 1,
            samplehold: (t, phase) => {
                 // Keeping samplehold for compatibility but user sees "Noise" now
                const f = 1; 
                const key = Math.floor((t + phase) / f);
                if (!waveforms._sampleValues.hasOwnProperty(key)) {
                    waveforms._sampleValues[key] = Math.random() * 2 - 1; 
                }
                return waveforms._sampleValues[key];
            },
            _sampleValues: {},
            
            // NEW NOISE WAVEFORM (Value Noise)
            noise: (t, phase) => {
                 // Map input to a continuous but random-looking signal
                 // t + phase will be our coordinate
                 const x = (t + phase) / Math.PI; // Scaling factor
                 const i = Math.floor(x);
                 const f = x - i;
                 
                 // Smoothstep interpolation
                 const u = f * f * (3.0 - 2.0 * f);
                 
                 // Deterministic random based on integer step
                 const r1 = seededRandom(i);
                 const r2 = seededRandom(i + 1);
                 
                 // Map 0..1 to -1..1
                 const val = (r1 * (1 - u) + r2 * u);
                 return val * 2 - 1; 
            }
        };

        function seededRandom(seed) {
            let t = seed += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }

        // Initialize state with fallback 0s to prevent NaN
        let state = {
            startColor: controls.startColor.value,
            endColor: controls.endColor.value,
            tiltX: parseInt(controls.tiltX.value) || 0,
            panY: parseInt(controls.panY.value) || 0,
            perspective: parseInt(controls.perspective.value) || 1000,
            freq: parseInt(controls.freq.value) || 50,
            phase: parseFloat(controls.phase.value) || 0,
            startAmp: parseFloat(controls.startAmp.value) || 0,
            endAmp: parseFloat(controls.endAmp.value) || 40,
            startLineWidth: parseFloat(controls.startLineWidth.value) || 2.0,
            endLineWidth: parseFloat(controls.endLineWidth.value) || 2.0,
            ampLog: parseFloat(controls.ampLog.value) || 1.0,
            distLog: parseFloat(controls.distLog.value) || 0.81,
            pathLog: parseFloat(controls.pathLog.value) || 1.0,
            angleOffsetLog: parseFloat(controls.angleOffsetLog.value) || 1.0, 
            arrayRadius: parseFloat(controls.arrayRadius.value) || 267,
            count: parseInt(controls.count.value) || 80, 
            concentricCount: parseInt(controls.concentricCount.value) || 50,
            concRotStart: parseInt(controls.concRotStart.value) || 0, 
            concRotEnd: parseInt(controls.concRotEnd.value) || 0, 
            startRadius: parseInt(controls.startRadius.value) || 20, 
            endRadius: parseInt(controls.endRadius.value) || 350,
            numSpirals: parseInt(controls.numSpirals.value) || 1, 
            spiralTurns: parseFloat(controls.spiralTurns.value) || 0.5, 
            drawPathCurve: controls.drawPathCurve.checked, 
            selectedWaveform: 'sine',
            layoutMode: 'concentric', 
            modTarget: 'outline',
            arrayPath: 'fibonacci', 
            spiralType: 'fermat', 
            startBaseRadius: parseFloat(controls.startBaseRadius.value) || 50,
            endBaseRadius: parseFloat(controls.endBaseRadius.value) || 50,
            startSides: parseInt(controls.startSides.value) || 0,
            endSides: parseInt(controls.endSides.value) || 4,
            angleOffsetMode: 'rotateShapes', 
            dutyCycle: parseFloat(controls.dutyCycle.value) || 0.5,
            gradientDivisions: parseInt(controls.gradientDivisions.value) || 1,
            randomLengthMode: 'none', 
            seed: 1, 
            arrayStartAngle: parseInt(controls.arrayStartAngle.value) || 0, 
            arrayEndAngle: parseInt(controls.arrayEndAngle.value) || 360,
            radialRotStart: parseInt(controls.radialRotStart.value) || 90, 
            radialRotEnd: parseInt(controls.radialRotEnd.value) || 450, 
            globalRotation: parseInt(controls.globalRotation.value) || 0,
            gradientMode: 'angular',
            
            // FX
            trailsEnabled: controls.trailsEnabled.checked,
            trailDecay: parseFloat(controls.trailDecay.value) || 0.10,
            trailZ: parseInt(controls.trailZ.value) || 0,
            glowEnabled: controls.glowEnabled.checked,
            
            // Mod Options
            modLineShape: true,
            modStartRadius: false,
            modEndRadius: false
        };
        
        // ----- PRESET MANAGER LOGIC -----
        const PRESET_KEY = 'genArtPresets';

        function loadPresetsFromLS() {
            const saved = localStorage.getItem(PRESET_KEY);
            const presets = saved ? JSON.parse(saved) : {};
            controls.presetSelect.innerHTML = '<option value="" disabled selected>Select Preset...</option>';
            Object.keys(presets).sort().forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                controls.presetSelect.appendChild(option);
            });
            return presets;
        }

        function savePreset() {
            const name = controls.presetName.value.trim();
            if (!name) {
                alert("Please enter a preset name.");
                return;
            }
            const presets = loadPresetsFromLS();
            presets[name] = JSON.parse(JSON.stringify(state)); 
            localStorage.setItem(PRESET_KEY, JSON.stringify(presets));
            loadPresetsFromLS(); 
            controls.presetSelect.value = name; 
            controls.presetName.value = ""; 
        }

        function deletePreset() {
            const name = controls.presetSelect.value;
            if (!name) return;
            if (confirm(`Delete preset "${name}"?`)) {
                const presets = loadPresetsFromLS();
                delete presets[name];
                localStorage.setItem(PRESET_KEY, JSON.stringify(presets));
                loadPresetsFromLS();
            }
        }

        function applyPresetState(loadedState) {
            state = { ...state, ...loadedState }; 
            controls.startColor.value = state.startColor;
            controls.endColor.value = state.endColor;
            
            const numUpdates = [
                'tiltX', 'panY', 'perspective', 'freq', 'phase', 'startAmp', 'endAmp',
                'startLineWidth', 'endLineWidth', 'ampLog', 'distLog', 'pathLog',
                'angleOffsetLog', 'arrayRadius', 'count', 'concentricCount',
                'concRotStart', 'concRotEnd', 'startRadius', 'endRadius', 'numSpirals',
                'spiralTurns', 'startBaseRadius', 'endBaseRadius', 'startSides', 'endSides',
                'dutyCycle', 'gradientDivisions', 'arrayStartAngle', 'arrayEndAngle',
                'radialRotStart', 'radialRotEnd', 'globalRotation', 'trailDecay', 'trailZ'
            ];
            
            numUpdates.forEach(key => {
                if (controls[key]) { 
                   controls[key].value = state[key];
                   const numInput = document.getElementById(key + 'Num');
                   if (numInput) numInput.value = state[key];
                }
            });
            
            const setRadio = (name, val) => {
                const radios = document.querySelectorAll(`input[name="${name}"]`);
                radios.forEach(r => r.checked = (r.value === val));
            };
            setRadio('waveform', state.selectedWaveform);
            setRadio('layoutMode', state.layoutMode);
            setRadio('modTarget', state.modTarget);
            setRadio('arrayPath', state.arrayPath);
            setRadio('spiralType', state.spiralType);
            setRadio('angleOffsetMode', state.angleOffsetMode);
            setRadio('gradientMode', state.gradientMode);
            setRadio('randomLengthMode', state.randomLengthMode);
            
            controls.drawPathCurve.checked = state.drawPathCurve;
            controls.trailsEnabled.checked = state.trailsEnabled;
            controls.glowEnabled.checked = state.glowEnabled;
            controls.modLineShape.checked = state.modLineShape;
            controls.modStartRadius.checked = state.modStartRadius;
            controls.modEndRadius.checked = state.modEndRadius;
            
            controls.seedDisplay.textContent = state.seed;
            handleLayoutChange({ target: { value: state.layoutMode } });
            updateState();
        }

        controls.btnSavePreset.addEventListener('click', savePreset);
        controls.btnDeletePreset.addEventListener('click', deletePreset);
        controls.btnLoadPreset.addEventListener('click', () => {
            const name = controls.presetSelect.value;
            if (!name) return;
            const presets = loadPresetsFromLS();
            if (presets[name]) {
                applyPresetState(presets[name]);
            }
        });
        
        loadPresetsFromLS();

        let isAnimating = false;
        let animDirection = 1; 
        let animationId = null;

        function animate() {
            if (!isAnimating) return;
            state.phase += 0.005 * animDirection;
            if (state.phase >= 2) state.phase -= 2;
            if (state.phase < 0) state.phase += 2;
            controls.phase.value = state.phase;
            document.getElementById('phaseNum').value = state.phase.toFixed(2);
            draw();
            animationId = requestAnimationFrame(animate);
        }

        controls.animToggle.addEventListener('click', () => {
            isAnimating = !isAnimating;
            if (isAnimating) {
                controls.animToggle.textContent = "Stop";
                controls.animToggle.classList.add('active');
                animate();
            } else {
                controls.animToggle.textContent = "Play";
                controls.animToggle.classList.remove('active');
                if (animationId) cancelAnimationFrame(animationId);
            }
        });
        controls.animRev.addEventListener('click', () => {
            animDirection = -1;
            controls.animRev.classList.add('selected');
            controls.animFwd.classList.remove('selected');
        });
        controls.animFwd.addEventListener('click', () => {
            animDirection = 1;
            controls.animFwd.classList.add('selected');
            controls.animRev.classList.remove('selected');
        });
        
        controls.trailsEnabled.addEventListener('change', updateState);
        controls.trailDecay.addEventListener('input', updateState);
        controls.trailZ.addEventListener('input', updateState);
        controls.glowEnabled.addEventListener('change', updateState);
        
        controls.modLineShape.addEventListener('change', updateState);
        controls.modStartRadius.addEventListener('change', updateState);
        controls.modEndRadius.addEventListener('change', updateState);


        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : {r:0,g:0,b:0};
        }

        function lerpColor(c1, c2, t) {
            const r = Math.round(c1.r + (c2.r - c1.r) * t);
            const g = Math.round(c1.g + (c2.g - c1.g) * t);
            const b = Math.round(c1.b + (c2.b - c1.b) * t);
            return `rgb(${r},${g},${b})`;
        }

        function applyLogScale(t, logFactor) {
            return Math.pow(t, logFactor);
        }

        function getInterpolatedAmplitude(i, total) {
            const range = state.endAmp - state.startAmp;
            let t = (total > 1) ? i / (total - 1) : 0; 
            t = applyLogScale(t, state.ampLog);
            return state.startAmp + range * t;
        }
        
        function getInterpolatedBaseRadius(i, total) {
            const range = state.endRadius - state.startRadius; 
            let t = (total > 1) ? i / (total - 1) : 0;
            
            if (state.layoutMode === 'concentric') {
                const isSpiral = (state.angleOffsetMode === 'rotateCenters');
                if (!isSpiral && i === 0 && state.distLog < 1.0 && total > 1) {
                    let t_next = 1 / (total - 1);
                    let scaled_t_next = applyLogScale(t_next, state.distLog);
                    let r_next = state.startRadius + range * scaled_t_next;
                    let closure = 1.0 - state.distLog; 
                    let adj = closure * 0.9; 
                    return state.startRadius + (r_next - state.startRadius) * adj;
                }
                const scaled_t_radius = applyLogScale(t, state.distLog);
                return state.startRadius + range * scaled_t_radius;
            } else {
                return state.startRadius + range * t; 
            }
        }

        function getInterpolatedSides(i, total) {
            const range = state.endSides - state.startSides;
            let t = (total > 1) ? i / (total - 1) : 0; 
            return state.startSides + range * t;
        }

        function getInterpolatedLineWidth(i, total) {
            const range = state.endLineWidth - state.startLineWidth;
            const t = (total > 1) ? i / (total - 1) : 0;
            return state.startLineWidth + range * t;
        }

        function getInterpolatedColor(i, total) {
            const c1 = hexToRgb(state.startColor);
            const c2 = hexToRgb(state.endColor);
            let t = (total > 1) ? i / (total - 1) : 0;
            let scaledT = t * (state.gradientDivisions || 1);
            if (scaledT > 0 && scaledT % 1 === 0) t = 1;
            else t = scaledT % 1;
            return lerpColor(c1, c2, t);
        }

        function calculateShapeRadius(overallIndex, totalOverallCount) {
             const currentAmp = getInterpolatedAmplitude(overallIndex, totalOverallCount); 
             const currentBaseRadius = getInterpolatedBaseRadius(overallIndex, totalOverallCount); 

             if (state.modTarget === 'outline') {
                return currentBaseRadius + Math.abs(currentAmp) * 0.05; 
             } else {
                return currentBaseRadius + Math.abs(currentAmp); 
             }
        }
        
        function getShapeR(sides, angle, baseR) {
            if (sides < MIN_POLYGON_SIDES) return baseR; 
            sides = Math.min(MAX_POLYGON_SIDES, Math.round(sides));
            const initialRotation = Math.PI / 2; 
            const rotationPerSide = (Math.PI * 2) / sides;
            const halfRotationPerSide = rotationPerSide / 2;
            let polarAngle = angle + initialRotation; 
            let angleToApothem = polarAngle % rotationPerSide;
            if (angleToApothem < 0) angleToApothem += rotationPerSide;
            let angleFromCenterSide = Math.abs(angleToApothem - halfRotationPerSide);
            return baseR / Math.cos(angleFromCenterSide);
        }

        function getPolygonVertices(N_sides, R_base, numSegments, angleOffset) {
            const vertices = [];
            if (N_sides < MIN_POLYGON_SIDES) {
                for (let i = 0; i < numSegments; i++) {
                     const angle = (i / numSegments) * Math.PI * 2 + angleOffset; 
                     vertices.push({ x: Math.cos(angle) * R_base, y: Math.sin(angle) * R_base, angle: angle });
                }
                return vertices;
            }
            const N = Math.round(N_sides);
            for (let i = 0; i < numSegments; i++) {
                const t = i / numSegments;
                const angle = t * Math.PI * 2 + angleOffset;
                const R = getShapeR(N, angle - angleOffset, R_base); 
                vertices.push({ x: Math.cos(angle) * R, y: Math.sin(angle) * R, angle: angle });
            }
            return vertices;
        }

        function drawDistortedCircle(center, baseR, currentAmplitude, currentLineWidth, currentColor, svgElements, angleOffset = 0) {
            const segments = svgElements ? EXPORT_SEGMENTS : SCREEN_SEGMENTS;
            const distortionAmp = currentAmplitude * 0.05; 
            const phaseNorm = state.phase / 2; 
            const cycles = state.freq;
            let points = []; 

            for (let j = 0; j <= segments; j++) {
                const angle = (j / segments) * Math.PI * 2; 
                const effectiveAngle = angle + angleOffset; 
                const modInput = (angle * cycles) / (Math.PI * 2) + phaseNorm; 
                const modValue = waveforms[state.selectedWaveform](modInput * Math.PI * 2, 0); 
                const currentR = baseR - ((modValue + 1) / 2) * distortionAmp; 
                const x = center.x + Math.cos(effectiveAngle) * currentR;
                const y = center.y + Math.sin(effectiveAngle) * currentR;
                points.push({ x, y });
            }
            
            ctx.beginPath();
            if (points.length > 0) {
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
            }
            ctx.closePath();
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = currentLineWidth;
            ctx.stroke();

            if (svgElements && points.length > 3) { 
                let pathData = `M ${points[0].x.toFixed(2)} ${points[0].y.toFixed(2)}`;
                for (let i = 1; i < points.length - 1; i++) {
                    pathData += ` L ${points[i].x.toFixed(2)} ${points[i].y.toFixed(2)}`;
                }
                const svgPath = `<path d="${pathData} Z" stroke="${currentColor}" stroke-width="${currentLineWidth.toFixed(2)}" fill="none" vector-effect="non-scaling-stroke"/>`;
                svgElements.push(svgPath);
            }
        }

        function drawDistortedShape(center, baseR, currentAmplitude, currentLineWidth, currentColor, interpolatedSides, svgElements, angleOffset = 0) {
            const N_start = state.startSides;
            const N_end = state.endSides;
            
            if (N_start < MIN_POLYGON_SIDES && N_end < MIN_POLYGON_SIDES) {
                 return drawDistortedCircle(center, baseR, currentAmplitude, currentLineWidth, currentColor, svgElements, angleOffset);
            }
            
            const N_start_clamped = N_start < MIN_POLYGON_SIDES ? 0 : N_start;
            const N_end_clamped = N_end < MIN_POLYGON_SIDES ? 0 : N_end;
            const denominator = N_end_clamped - N_start_clamped;
            let T = 0;
            if (denominator !== 0) T = (interpolatedSides - N_start_clamped) / denominator;

            const numPoints = 360; 
            const finalPoints = [];
            
            const verticesA = getPolygonVertices(N_start_clamped, baseR, numPoints, angleOffset);
            const verticesB = getPolygonVertices(N_end_clamped, baseR, numPoints, angleOffset);
            
            const waveFn = waveforms[state.selectedWaveform];
            const distortionAmp = currentAmplitude * 0.05; 
            
            const phaseNorm = state.phase / 2; 
            const cycles = state.freq;

            for (let i = 0; i < numPoints; i++) {
                const R_A = Math.sqrt(verticesA[i].x**2 + verticesA[i].y**2);
                const R_B = Math.sqrt(verticesB[i].x**2 + verticesB[i].y**2);
                const R_unmodulated = R_A * (1 - T) + R_B * T;
                const angle_rotated = verticesA[i].angle;
                const angle_for_mod = angle_rotated - angleOffset;
                const modInput = (angle_for_mod * cycles / (Math.PI * 2)) + phaseNorm; 
                const modValue = waveFn(modInput * Math.PI * 2, 0); 
                const currentR = R_unmodulated - ((modValue + 1) / 2) * distortionAmp; 
                const x = center.x + Math.cos(angle_rotated) * currentR;
                const y = center.y + Math.sin(angle_rotated) * currentR;
                finalPoints.push({ x, y });
            }

            const drawPoints = finalPoints;
            if (drawPoints.length > 0) drawPoints.pop(); 
            
            ctx.beginPath();
            if (drawPoints.length > 0) {
                ctx.moveTo(drawPoints[0].x, drawPoints[0].y);
                for (let i = 1; i < drawPoints.length; i++) {
                    ctx.lineTo(drawPoints[i].x, drawPoints[i].y);
                }
            }
            ctx.closePath();
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = currentLineWidth;
            ctx.stroke();

            if (svgElements && drawPoints.length > 1) {
                let pathData = `M ${drawPoints[0].x.toFixed(2)} ${drawPoints[0].y.toFixed(2)}`;
                for (let i = 1; i < drawPoints.length; i++) {
                    pathData += ` L ${drawPoints[i].x.toFixed(2)} ${drawPoints[i].y.toFixed(2)}`;
                }
                pathData += ` Z`;
                const svgPath = `<path d="${pathData}" stroke="${currentColor}" stroke-width="${currentLineWidth.toFixed(2)}" fill="none" vector-effect="non-scaling-stroke"/>`;
                svgElements.push(svgPath);
            }
        }

        function drawRadiatingLines(svgData, svgDefs) {
            const N = state.count;
            if (N < 1) return;

            const globalStartR = state.startRadius;
            const globalEndR = state.endRadius;
            const phaseNorm = state.phase / 2; 
            const rotStartRad = state.concRotStart * (Math.PI / 180);
            const rotEndRad = state.concRotEnd * (Math.PI / 180);
            
            for (let i = 0; i < N; i++) {
                let R_inner = globalStartR;
                let R_outer = globalEndR;
                const seedMix = i * 1337 + state.seed * 7919; 
                const r1 = seededRandom(seedMix); 
                const r2 = seededRandom(seedMix + 9999);
                
                // Apply Random Length Logic
                if (state.randomLengthMode !== 'none') {
                    const rangeGlobal = globalEndR - globalStartR;
                    const offset1 = r1 * rangeGlobal * 0.9; 
                    const offset2 = r2 * rangeGlobal * 0.9;

                    if (state.randomLengthMode === 'start') {
                        R_inner = globalStartR + offset1;
                    } else if (state.randomLengthMode === 'end') {
                        R_outer = globalEndR - offset1;
                    } else if (state.randomLengthMode === 'both') {
                        R_inner = globalStartR + offset1;
                        R_outer = globalEndR - offset2;
                        if (R_outer <= R_inner) {
                             const mid = (globalStartR + globalEndR)/2;
                             R_inner = mid - 10;
                             R_outer = mid + 10;
                        }
                    }
                }
                
                // Apply Modulation Logic
                // Calculate line-based modulation factor
                let modLineFactor = 0;
                
                // Use a consistent coordinate for the line's noise/sine pickup
                // For radiating lines, 'i' is the angular index.
                const t_line_index = i / N;
                // For modulation, we can use (t_line_index * freq) + phaseNorm
                // This makes the modulation ripple AROUND the circle
                
                const modInputLine = (t_line_index * state.freq) + phaseNorm;
                const waveFn = waveforms[state.selectedWaveform];
                const modValueLine = waveFn(modInputLine * Math.PI * 2, 0); 
                
                // Apply Start/End Modulation
                if (state.modStartRadius) {
                     // Use Start Amplitude to affect Inner Radius
                     R_inner += modValueLine * state.startAmp; 
                }
                
                if (state.modEndRadius) {
                     // Use End Amplitude to affect Outer Radius
                     R_outer += modValueLine * state.endAmp;
                }

                const localRange = R_outer - R_inner;
                let spinePoints = [];
                const segments = RADIATING_LINE_SEGMENTS;
                
                for(let j = 0; j <= segments; j++) {
                    const t = j / segments; 
                    const currentR = R_inner + (t * localRange);
                    
                    let globalT = 0;
                    const rangeGlobal = globalEndR - globalStartR;
                    if (rangeGlobal > 0) {
                        globalT = (currentR - globalStartR) / rangeGlobal;
                    }

                    const twistT = applyLogScale(globalT, state.angleOffsetLog);
                    const twistAngle = rotStartRad + (rotEndRad - rotStartRad) * twistT;

                    let angleDisplacement = 0;
                    
                    // Apply Shape Bend Modulation ONLY if enabled
                    if (state.modLineShape) {
                        let t_amp_curve = globalT; 
                        if (state.ampLog !== 1.0) t_amp_curve = Math.pow(globalT, state.ampLog);
                        const currentSegmentAmp = state.startAmp + (state.endAmp - state.startAmp) * t_amp_curve;

                        // For bending, modulation moves OUTWARD along the line
                        const modInputBend = (globalT * state.freq) + phaseNorm;
                        const modValueBend = waveFn(modInputBend * Math.PI * 2, 0);
                        
                        if (currentR > 0.1) {
                             angleDisplacement = (modValueBend * currentSegmentAmp * 0.5) / currentR; 
                        }
                    }
                    
                    const finalAngle = twistAngle + angleDisplacement + (i / N) * Math.PI * 2;
                    const x = centerX + Math.cos(finalAngle) * currentR;
                    const y = centerY + Math.sin(finalAngle) * currentR;
                    
                    const currentWidth = state.startLineWidth + (state.endLineWidth - state.startLineWidth) * globalT;
                    spinePoints.push({x, y, w: currentWidth});
                }
                
                let leftEdge = [];
                let rightEdge = [];
                for (let k = 0; k < spinePoints.length; k++) {
                    const curr = spinePoints[k];
                    let next = spinePoints[k + 1];
                    let prev = spinePoints[k - 1];
                    let dx, dy;
                    if (k === 0) {
                        dx = next.x - curr.x;
                        dy = next.y - curr.y;
                    } else if (k === spinePoints.length - 1) {
                        dx = curr.x - prev.x;
                        dy = curr.y - prev.y;
                    } else {
                        dx = next.x - prev.x;
                        dy = next.y - prev.y;
                    }
                    const len = Math.sqrt(dx*dx + dy*dy);
                    if (len === 0) continue; 
                    const ndx = dx / len;
                    const ndy = dy / len;
                    const perpX = -ndy;
                    const perpY = ndx;
                    const halfW = curr.w / 2;
                    leftEdge.push({ x: curr.x + perpX * halfW, y: curr.y + perpY * halfW });
                    rightEdge.push({ x: curr.x - perpX * halfW, y: curr.y - perpY * halfW });
                }

                const fullPoly = [...leftEdge, ...rightEdge.reverse()];
                ctx.beginPath();
                if (fullPoly.length > 0) {
                    ctx.moveTo(fullPoly[0].x, fullPoly[0].y);
                    for (let p = 1; p < fullPoly.length; p++) {
                        ctx.lineTo(fullPoly[p].x, fullPoly[p].y);
                    }
                }
                ctx.closePath(); 

                let fillStyle;
                let svgFill;

                if (state.gradientMode === 'angular') {
                    fillStyle = getInterpolatedColor(i, N);
                    svgFill = fillStyle;
                } else {
                    const startPt = spinePoints[0];
                    const endPt = spinePoints[spinePoints.length - 1];
                    const grad = ctx.createLinearGradient(startPt.x, startPt.y, endPt.x, endPt.y);
                    grad.addColorStop(0, state.startColor);
                    grad.addColorStop(1, state.endColor);
                    fillStyle = grad;

                    if (svgDefs) {
                        const gradId = `grad_poly_${i}`;
                        const def = `<linearGradient id="${gradId}" x1="${startPt.x.toFixed(2)}" y1="${startPt.y.toFixed(2)}" x2="${endPt.x.toFixed(2)}" y2="${endPt.y.toFixed(2)}" gradientUnits="userSpaceOnUse">
                            <stop offset="0%" stop-color="${state.startColor}" />
                            <stop offset="100%" stop-color="${state.endColor}" />
                        </linearGradient>`;
                        svgDefs.push(def);
                        svgFill = `url(#${gradId})`;
                    }
                }
                ctx.fillStyle = fillStyle;
                ctx.fill();
                if (svgData && fullPoly.length > 1) {
                    let pathData = `M ${fullPoly[0].x.toFixed(2)} ${fullPoly[0].y.toFixed(2)}`;
                    for (let p = 1; p < fullPoly.length; p++) {
                        pathData += ` L ${fullPoly[p].x.toFixed(2)} ${fullPoly[p].y.toFixed(2)}`;
                    }
                    pathData += " Z"; 
                    const svgPath = `<path d="${pathData}" fill="${svgFill}" stroke="none"/>`;
                    svgData.push(svgPath);
                }
            }
        }
        
        function calculateSpiralAngle(i, N, totalSpirals, maxSpiralAngle, spiralOffset, s) {
            if (state.spiralType === 'fermat') {
                const t_linear = N > 0 ? (i + 1) / N : 0; 
                const baseAngle = t_linear * maxSpiralAngle; 
                return baseAngle + spiralOffset;
            } else { 
                const overall_index_in_total = (s * N) + i; 
                const baseAngle = overall_index_in_total * GOLDEN_ANGLE;
                return baseAngle; 
            }
        }
        
        function calculateSpiralRadius(i, N, R_max_center, totalSpirals) {
            let t_linear = N > 0 ? (i + 1) / N : 0; 
            let t_radial = applyLogScale(t_linear, state.pathLog); 
            let R_unscaled = Math.pow(t_radial, 0.5); 
            return R_unscaled * R_max_center;
        }

        function drawHighPrecisionSpiralPath() {
            if (state.arrayPath !== 'fibonacci') return; 
            ctx.strokeStyle = '#FF00FF'; 
            ctx.lineWidth = 1; 
            const count_per_spiral = state.count;
            const maxAngle = state.spiralTurns * Math.PI * 2; 
            for (let s = 0; s < state.numSpirals; s++) {
                ctx.beginPath();
                const spiralOffset = s * (Math.PI * 2 / state.numSpirals);
                const N = count_per_spiral;
                if (N <= 0) continue; 
                const R_last = calculateShapeRadius(N - 1, N);
                const R_max_center_boundary = state.arrayRadius - R_last; 
                for (let i = 0; i < SPIRAL_DEBUG_SEGMENTS; i++) {
                    const t_linear = (i + 1) / SPIRAL_DEBUG_SEGMENTS; 
                    const t_radial = applyLogScale(t_linear, state.pathLog);
                    const radius = Math.pow(t_radial, 0.5) * R_max_center_boundary;
                    let angle;
                    if(state.spiralType === 'fermat') {
                        const baseAngle = t_linear * maxAngle;
                        angle = baseAngle + spiralOffset;
                    } else {
                         const virtual_index = t_linear * N;
                         const overall_index = (s * N) + virtual_index;
                         angle = overall_index * GOLDEN_ANGLE;
                    }
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
        }

        function drawRadialArray(svgData) {
            const phaseNorm = state.phase / 2; 
            const N = state.count; 
            const totalSpirals = state.numSpirals;
            const maxSpiralAngle = state.spiralTurns * Math.PI * 2; 

            if (state.arrayPath === 'fibonacci' && state.drawPathCurve && !svgData) {
                drawHighPrecisionSpiralPath();
            }
            if (N === 0) return;

            const R_first = calculateShapeRadius(0, N); 
            const R_last = calculateShapeRadius(N - 1, N);
            const R_max_center_boundary = state.arrayRadius - R_last;
            
            const startAngleRad = state.arrayStartAngle * (Math.PI / 180);
            const endAngleRad = state.arrayEndAngle * (Math.PI / 180);
            const totalAngleRange = endAngleRad - startAngleRad;
            
            const shapeRotStartRad = state.radialRotStart * (Math.PI / 180);
            const shapeRotEndRad = state.radialRotEnd * (Math.PI / 180);

            for (let s = 0; s < totalSpirals; s++) { 
                for (let i = 0; i < N; i++) { 
                    let angle;
                    let radius;
                    let t = (N > 1) ? i / (N - 1) : 0; 
                    if (N === 1) t = 0;
                    
                    const currentBaseRadius = getInterpolatedBaseRadius(i, N); 
                    const currentAmp = getInterpolatedAmplitude(i, N); 
                    const currentLineWidth = getInterpolatedLineWidth(i, N); 
                    const currentColor = getInterpolatedColor(i, N); 
                    const modInput = i * state.freq;
                    const interpolatedSides = getInterpolatedSides(i, N); 
                    
                    if (state.arrayPath === 'fibonacci') {
                        radius = calculateSpiralRadius(i, N, R_max_center_boundary, totalSpirals);
                        const spiralOffset = s * (Math.PI * 2 / totalSpirals);
                        angle = calculateSpiralAngle(i, N, totalSpirals, maxSpiralAngle, spiralOffset, s);
                    } else { 
                        radius = state.arrayRadius; 
                        angle = startAngleRad + t * totalAngleRange;
                    }

                    const x = centerX + Math.cos(angle) * radius; 
                    const y = centerY + Math.sin(angle) * radius;
                    const center = { x, y };
                    
                    let shapeRotation = 0;
                    if (state.arrayPath === 'radial') {
                        shapeRotation = shapeRotStartRad + t * (shapeRotEndRad - shapeRotStartRad);
                    }

                    if (state.modTarget === 'outline') {
                        drawDistortedShape(center, currentBaseRadius, currentAmp, currentLineWidth, currentColor, interpolatedSides, svgData, shapeRotation); 
                    } else { 
                        const modValue = waveforms[state.selectedWaveform](modInput, phaseNorm * Math.PI * 2); 
                        const currentRadius = currentBaseRadius + modValue * currentAmp; 
                        ctx.beginPath();
                        ctx.arc(x, y, Math.max(0.5, currentRadius), 0, Math.PI * 2); 
                        ctx.strokeStyle = currentColor;
                        ctx.lineWidth = currentLineWidth;
                        ctx.stroke();
                        if (svgData) {
                            svgData.push(`<circle cx="${x.toFixed(2)}" cy="${y.toFixed(2)}" r="${Math.max(0.5, currentRadius).toFixed(2)}" stroke="${currentColor}" stroke-width="${currentLineWidth.toFixed(2)}" fill="none"/>`);
                        }
                    }
                }
            }
        }

        function drawConcentricShapes(svgData) {
            const center = { x: centerX, y: centerY };
            const totalCount = state.concentricCount;
            const rotStartRad = state.concRotStart * (Math.PI / 180);
            const rotEndRad = state.concRotEnd * (Math.PI / 180);
            
            for (let i = 0; i < totalCount; i++) {
                if (state.angleOffsetMode === 'rotateCenters' && state.distLog < 1.0 && i === 0) {
                    continue;
                }

                let t_index = (totalCount > 1) ? i / (totalCount - 1) : 0;
                const t_log_angle = applyLogScale(t_index, state.angleOffsetLog);
                const currentAngle = rotStartRad + (rotEndRad - rotStartRad) * t_log_angle;

                const currentShapeBaseR = getInterpolatedBaseRadius(i, totalCount);
                
                let currentCenterR = 0;
                let shapeRotationAngle = 0;
                
                if (state.angleOffsetMode === 'rotateCenters') {
                    const spiralMaxR = state.endRadius;
                    currentCenterR = applyLogScale(t_index, state.distLog) * spiralMaxR;
                    shapeRotationAngle = currentAngle; 
                } else if (state.angleOffsetMode === 'rotateShapes') {
                    currentCenterR = 0; 
                    shapeRotationAngle = currentAngle; 
                }

                const currentAmp = getInterpolatedAmplitude(i, totalCount); 
                const currentLineWidth = getInterpolatedLineWidth(i, totalCount); 
                const currentColor = getInterpolatedColor(i, totalCount);
                const interpolatedSides = getInterpolatedSides(i, totalCount);

                const shapeCenter = { 
                    x: centerX + Math.cos(shapeRotationAngle) * currentCenterR, 
                    y: centerY + Math.sin(shapeRotationAngle) * currentCenterR 
                };

                if (state.modTarget === 'outline') {
                    drawDistortedShape(shapeCenter, currentShapeBaseR, currentAmp, currentLineWidth, currentColor, interpolatedSides, svgData, shapeRotationAngle); 
                } else { 
                    const phaseNorm = state.phase / 2; 
                    const modInput = t_index * totalCount * state.freq; 
                    const modValue = waveforms[state.selectedWaveform](modInput, phaseNorm * Math.PI * 2); 
                    const currentRadius = currentShapeBaseR + modValue * currentAmp; 
                    ctx.beginPath();
                    ctx.arc(shapeCenter.x, shapeCenter.y, Math.max(1, currentRadius), 0, Math.PI * 2); 
                    ctx.strokeStyle = currentColor;
                    ctx.lineWidth = currentLineWidth;
                    ctx.stroke();
                    if (svgData) {
                        svgData.push(`<circle cx="${shapeCenter.x.toFixed(2)}" cy="${shapeCenter.y.toFixed(2)}" r="${Math.max(1, currentRadius).toFixed(2)}" stroke="${currentColor}" stroke-width="${currentLineWidth.toFixed(2)}" fill="none"/>`);
                    }
                }
            }
        }

        function draw(exporting = false) {
            if (!exporting) {
                // FX LOGIC
                if (state.trailsEnabled) {
                    if (state.glowEnabled) {
                         ctx.globalCompositeOperation = 'lighter';
                    } else {
                         ctx.globalCompositeOperation = 'source-over';
                    }
                    const savedOp = ctx.globalCompositeOperation;
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.fillStyle = `rgba(0, 0, 0, ${state.trailDecay})`;
                    ctx.fillRect(0, 0, W, H);
                    if (state.trailZ > 0) {
                        const shrinkage = state.trailZ;
                        ctx.drawImage(canvas, shrinkage/2, shrinkage/2, W-shrinkage, H-shrinkage);
                    }
                    ctx.globalCompositeOperation = savedOp;
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.clearRect(0, 0, W, H);
                }
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, W, H);
            }

            let svgElements = exporting ? [] : null;
            let svgDefs = exporting ? [] : null;

            if (state.selectedWaveform === 'samplehold') waveforms._sampleValues = {};
            
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(state.globalRotation * Math.PI / 180); 
            ctx.translate(-centerX, -centerY);

            if (state.layoutMode === 'radiating') {
                drawRadiatingLines(svgElements, svgDefs); 
            } else if (state.layoutMode === 'radial') {
                drawRadialArray(svgElements);
            } else {
                drawConcentricShapes(svgElements);
            }
            
            ctx.restore();
            
            return { elements: svgElements, defs: svgDefs };
        }

        function formatSideValue(value) {
            return value === 0 ? "Circle" : value;
        }

        function updateState() {
            const prevStartSides = state.startSides;
            const prevEndSides = state.endSides;
            let newStartSides = parseInt(controls.startSides.value);
            let newEndSides = parseInt(controls.endSides.value);
            const snapSides = (value, previousValue) => {
                if (value === 1 || value === 2) {
                    if (previousValue >= MIN_POLYGON_SIDES) return MIN_POLYGON_SIDES;
                    else return 0;
                }
                return value;
            };
            newStartSides = snapSides(newStartSides, prevStartSides);
            newEndSides = snapSides(newEndSides, prevEndSides);
            controls.startSides.value = newStartSides;
            controls.endSides.value = newEndSides;

            state.startColor = controls.startColor.value;
            state.endColor = controls.endColor.value;
            
            state.freq = parseInt(controls.freq.value);
            state.phase = parseFloat(controls.phase.value);
            state.startAmp = parseFloat(controls.startAmp.value);
            state.endAmp = parseFloat(controls.endAmp.value);
            state.startLineWidth = parseFloat(controls.startLineWidth.value);
            state.endLineWidth = parseFloat(controls.endLineWidth.value);
            state.ampLog = parseFloat(controls.ampLog.value);
            state.distLog = parseFloat(controls.distLog.value);
            state.pathLog = parseFloat(controls.pathLog.value);
            state.angleOffsetLog = parseFloat(controls.angleOffsetLog.value); 
            state.arrayRadius = parseFloat(controls.arrayRadius.value);
            state.count = parseInt(controls.count.value);
            state.concentricCount = parseInt(controls.concentricCount.value);
            state.concRotStart = parseInt(controls.concRotStart.value); 
            state.concRotEnd = parseInt(controls.concRotEnd.value); 
            state.startRadius = parseInt(controls.startRadius.value); 
            state.endRadius = parseInt(controls.endRadius.value);
            state.numSpirals = parseInt(controls.numSpirals.value); 
            state.spiralTurns = parseFloat(controls.spiralTurns.value); 
            state.drawPathCurve = controls.drawPathCurve.checked; 
            state.selectedWaveform = document.querySelector('input[name="waveform"]:checked').value;
            state.layoutMode = document.querySelector('input[name="layoutMode"]:checked').value;
            state.modTarget = document.querySelector('input[name="modTarget"]:checked').value;
            state.arrayPath = document.querySelector('input[name="arrayPath"]:checked')?.value || 'radial'; 
            state.spiralType = document.querySelector('input[name="spiralType"]:checked')?.value || 'fermat'; 
            state.angleOffsetMode = document.querySelector('input[name="angleOffsetMode"]:checked').value;
            state.gradientMode = document.querySelector('input[name="gradientMode"]:checked').value; 
            state.startBaseRadius = parseFloat(controls.startBaseRadius.value);
            state.endBaseRadius = parseFloat(controls.endBaseRadius.value);
            state.startSides = newStartSides; 
            state.endSides = newEndSides;     
            state.dutyCycle = parseFloat(controls.dutyCycle.value);
            state.globalRotation = parseInt(controls.globalRotation.value);
            state.gradientDivisions = parseInt(controls.gradientDivisions.value);
            state.randomLengthMode = document.querySelector('input[name="randomLengthMode"]:checked').value; 
            state.arrayStartAngle = parseInt(controls.arrayStartAngle.value); 
            state.arrayEndAngle = parseInt(controls.arrayEndAngle.value);
            state.radialRotStart = parseInt(controls.radialRotStart.value); 
            state.radialRotEnd = parseInt(controls.radialRotEnd.value); 
            
            state.trailsEnabled = controls.trailsEnabled.checked;
            state.trailDecay = parseFloat(controls.trailDecay.value);
            state.trailZ = parseInt(controls.trailZ.value);
            state.glowEnabled = controls.glowEnabled.checked;
            
            state.modLineShape = controls.modLineShape.checked;
            state.modStartRadius = controls.modStartRadius.checked;
            state.modEndRadius = controls.modEndRadius.checked;

            if (controls.startSidesLabelSpan) controls.startSidesLabelSpan.textContent = formatSideValue(state.startSides);
            if (controls.endSidesLabelSpan) controls.endSidesLabelSpan.textContent = formatSideValue(state.endSides);
            
            if (state.selectedWaveform === 'square') {
                controls.dutyCycleGroup.classList.remove('hidden');
            } else {
                controls.dutyCycleGroup.classList.add('hidden');
            }

            if (state.gradientMode === 'angular' && (state.layoutMode === 'radiating' || state.layoutMode === 'radial')) {
                controls.gradientCyclesGroup.classList.remove('hidden');
            } else {
                controls.gradientCyclesGroup.classList.add('hidden');
            }

            draw();
        }

        function handleLayoutChange(event) {
            state.layoutMode = event.target.value;
            
            controls.radialControls.classList.add('hidden');
            controls.concentricControls.classList.add('hidden');
            controls.modTargetGroup.classList.remove('hidden');
            controls.radiatingModOptions.classList.add('hidden'); // Hide by default
            
            // Toggle Groups Based on Mode
            if (state.layoutMode === 'radiating') {
                controls.shapeMorphGroup.classList.add('hidden');
                controls.randomLengthGroup.classList.remove('hidden');
                controls.radialAngleGroup.classList.add('hidden');
                controls.radialShapeRotGroup.classList.add('hidden'); 
                controls.concentricRotationGroup.classList.remove('hidden'); 
                controls.radiatingModOptions.classList.remove('hidden'); // Show Mod Options
            } else if (state.layoutMode === 'radial') {
                controls.shapeMorphGroup.classList.remove('hidden');
                controls.randomLengthGroup.classList.add('hidden');
                controls.radialAngleGroup.classList.remove('hidden');
                controls.radialShapeRotGroup.classList.remove('hidden'); 
                controls.concentricRotationGroup.classList.add('hidden'); 
            } else {
                // Concentric
                controls.shapeMorphGroup.classList.remove('hidden');
                controls.randomLengthGroup.classList.add('hidden');
                controls.radialAngleGroup.classList.add('hidden');
                controls.radialShapeRotGroup.classList.add('hidden'); 
                controls.concentricRotationGroup.classList.remove('hidden'); 
            }
            
            if (state.layoutMode === 'radial') {
                controls.radialControls.classList.remove('hidden');
                controls.sharedCountControl.classList.remove('hidden'); 
                if (startRadiusLabelText) startRadiusLabelText.textContent = 'Start Shape Base Radius:';
                if (endRadiusLabelText) endRadiusLabelText.textContent = 'End Shape Base Radius:';
                handleArrayPathChange(); 
            } else if (state.layoutMode === 'concentric') {
                controls.concentricControls.classList.remove('hidden');
                controls.sharedCountControl.classList.add('hidden'); 
                controls.rotationModeGroup.classList.remove('hidden');
                controls.concentricCountGroup.classList.remove('hidden');
                
                if (twistLabel) twistLabel.textContent = "Rotation Amount (x π):";
                if (startRadiusLabelText) startRadiusLabelText.textContent = 'Inner Radius:';
                if (endRadiusLabelText) endRadiusLabelText.textContent = 'Outer Radius:';
            } else if (state.layoutMode === 'radiating') {
                controls.concentricControls.classList.remove('hidden'); 
                controls.sharedCountControl.classList.remove('hidden'); 
                
                controls.rotationModeGroup.classList.add('hidden');
                controls.concentricCountGroup.classList.add('hidden');
                controls.modTargetGroup.classList.add('hidden'); 

                if (twistLabel) twistLabel.textContent = "Spiral / Twist Amount:";
                if (startRadiusLabelText) startRadiusLabelText.textContent = 'Inner Radius:';
                if (endRadiusLabelText) endRadiusLabelText.textContent = 'Outer Radius:';
            }
            updateState();
        }
        
        function handleArrayPathChange() {
            const currentPath = document.querySelector('input[name="arrayPath"]:checked')?.value || 'radial';
            const labelTextSpan = document.getElementById('radiusLabelText');

            if (currentPath === 'fibonacci' && state.layoutMode === 'radial') {
                if (labelTextSpan) labelTextSpan.textContent = 'Max Array Radius: ';
                controls.numSpiralsGroup.classList.remove('fibonacci-hidden');
                controls.spiralTypeGroup.classList.remove('fibonacci-hidden');
                controls.pathLogGroup.classList.remove('fibonacci-hidden');
                controls.debugTools.classList.remove('fibonacci-hidden'); 
                controls.count.max = 1000;
                controls.radialAngleGroup.classList.add('hidden');
                controls.radialShapeRotGroup.classList.add('hidden'); 
                handleSpiralTypeChange(); 
            } else {
                if (labelTextSpan) labelTextSpan.textContent = 'Array Radius: '; 
                controls.numSpiralsGroup.classList.add('fibonacci-hidden');
                controls.spiralTurnsGroup.classList.add('fibonacci-hidden');
                controls.spiralTypeGroup.classList.add('fibonacci-hidden'); 
                controls.pathLogGroup.classList.add('fibonacci-hidden');
                controls.debugTools.classList.add('fibonacci-hidden'); 
                controls.count.max = 100;
                if(state.layoutMode === 'radial') {
                    controls.radialAngleGroup.classList.remove('hidden');
                    controls.radialShapeRotGroup.classList.remove('hidden'); 
                }
            }
            updateState();
        }

        function handleSpiralTypeChange() {
            const currentType = document.querySelector('input[name="spiralType"]:checked')?.value || 'fermat';
            state.spiralType = currentType;
            if (currentType === 'fermat') {
                controls.spiralTurnsGroup.classList.remove('fibonacci-hidden');
            } else {
                controls.spiralTurnsGroup.classList.add('fibonacci-hidden');
            }
            updateState();
        }
        
        function handleTargetChange(event) {
            state.modTarget = event.target.value;
            updateState(); 
        }
        
        function handleAngleOffsetModeChange(event) {
            state.angleOffsetMode = event.target.value;
            updateState();
        }

        function handleExport() {
            const result = draw(true); 
            const svgElements = result.elements;
            const svgDefs = result.defs ? result.defs.join('\n') : '';

            const transform = `rotate(${state.globalRotation}, ${centerX}, ${centerY})`;

            const svgString = `
<svg width="${W}" height="${H}" viewBox="0 0 ${W} ${H}" xmlns="http://www.w3.org/2000/svg">
    <defs>
        ${svgDefs}
    </defs>
    <rect width="100%" height="100%" fill="#000"/>
    <g transform="${transform}">
        ${svgElements.join('\n    ')}
    </g>
</svg>`.trim();

            const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'generative_art.svg';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        const allControls = Array.from(document.querySelectorAll('input[type="range"], input[type="color"], input[name="waveform"], input[name="modTarget"]'));
        allControls.forEach(control => control.addEventListener('input', updateState)); 
        
        controls.layoutRadios.forEach(radio => radio.addEventListener('change', handleLayoutChange));
        controls.arrayPathRadios.forEach(radio => radio.addEventListener('change', handleArrayPathChange)); 
        controls.spiralTypeRadios.forEach(radio => radio.addEventListener('change', handleSpiralTypeChange)); 
        controls.angleOffsetModeRadios.forEach(radio => radio.addEventListener('change', handleAngleOffsetModeChange));
        controls.gradientModeRadios.forEach(radio => radio.addEventListener('change', updateState)); 
        controls.waveformRadios.forEach(radio => radio.addEventListener('change', updateState));
        controls.randomLengthRadios.forEach(radio => radio.addEventListener('change', updateState)); 

        controls.numSpirals.addEventListener('input', updateState); 
        controls.spiralTurns.addEventListener('input', updateState); 
        controls.pathLog.addEventListener('input', updateState);
        controls.drawPathCurve.addEventListener('change', updateState);
        controls.exportButton.addEventListener('click', handleExport);
        // concentricAngleOffset removed
        controls.angleOffsetLog.addEventListener('input', updateState); 
        controls.targetRadios.forEach(radio => radio.addEventListener('change', handleTargetChange));

        controls.startBaseRadius.addEventListener('input', updateState);
        controls.endBaseRadius.addEventListener('input', updateState);
        
        controls.startRadius.addEventListener('input', updateState);
        controls.endRadius.addEventListener('input', updateState);
        
        controls.startSides.addEventListener('input', updateState);
        controls.endSides.addEventListener('input', updateState);

        // Seed Listeners
        controls.seedInc.addEventListener('click', () => {
            state.seed++;
            controls.seedDisplay.textContent = state.seed;
            draw();
        });
        controls.seedDec.addEventListener('click', () => {
            state.seed--;
            controls.seedDisplay.textContent = state.seed;
            draw();
        });
        
        // Defaults
        document.getElementById('concentric').checked = true;
        document.getElementById('targetOutline').checked = true;
        document.getElementById('rotateShapes').checked = true; 
        document.getElementById('square').checked = false; 
        document.getElementById('sine').checked = true;
        
        controls.freq.value = 50; 
        controls.phase.value = 0.00;
        controls.startAmp.value = 0; 
        controls.endAmp.value = 20; 
        controls.concentricCount.value = 60; 
        controls.distLog.value = 0.2;
        controls.angleOffsetLog.value = 1.00; 
        
        controls.startRadius.value = 20; 
        controls.endRadius.value = 350; 
        
        controls.startBaseRadius.value = 50; 
        controls.endBaseRadius.value = 50;   
        
        controls.startLineWidth.value = 2.0; 
        controls.endLineWidth.value = 2.0;   
        
        controls.startSides.value = 0; 
        controls.endSides.value = 4;   
        controls.count.value = 80;
        
        // Default FX
        controls.trailsEnabled.checked = false;
        controls.trailDecay.value = 0.1;
        controls.trailZ.value = 0;

        document.getElementById('pathFibonacci').checked = true;
        document.getElementById('typeFermat').checked = true;

        handleLayoutChange({ target: { value: 'concentric' } });
        
        // FINAL SAFETY CALL TO DRAW
        updateState();
    </script>

</body>
</html>

